
## 内存分配分析

#### 初始化函数

查看smali文件

- androidvm.MainActivity.init

 类的non-static field初始化
 ```
 .method public constructor <init>()V
 ```

- androidvm.MainActivity.clinit

 类的static filed初始化
 ```
 # direct methods
 .method static constructor <clinit>()V
 ```


相同点
- 都是由编译器添加在字节码文件中的
- 都是初始化函数

不同点
- 完成任务不同
 - clinit: 虚拟机将所有`类静态变量初始化语句`和`类的静态初始化语句`收集到一起，放到这个方法中；任务是初始化类（包括接口类）。
 - init: 任务是生成类对象，为对象分配内存空间。

    有以下四种调用时机：
    - 调用new操作符
    - 调用newInstance()方法
    - 调用clone方法
    - 通过反射生成类对象
- 调用的阶段不同
 - clinit: 类加载过程中的“初始化”阶段被调用，但是在此之前的“准备”阶段已经初始化这些类变量了。
 - init: 参考以上四种调用时机。



|变量\不同点|内存分配时机|分配空间位置|
|---------|---------|-----|
| 类变量   | "准备"阶段 |方法区|
| 实例变量 | "实例化"阶段| 堆 |
| 局部变量 | 运行时 | 堆和局部变量表 |


Java线程模型中各种存储空间
- 方法区
 - 存储已加载的类信息/类常量/类静态变量
 - 主要存储空间包括：
   - 运行时常量池
- 栈
 - VM栈
   - 描述Java方法执行的内存模型
   - 栈帧
     - 一个方法对应一个栈帧，方法的执行对应栈帧的创建/入栈/出栈等操作
     - 存储以下内容：
         - 局部变量表
         - 操作栈
         - 动态链接
         - 方法出口等信息
 - Native Method栈
   - native method的存储栈
- 堆
 - 存放对象实例，由GC管理；方法内的对象也在该区域创建，引用存储在局部变量表内
- 局部变量表
 - 存储栈帧内部的变量，包括：
   - 基本数据类型(long, int, short等)
   - 对象引用
   - 返回类型
 - 局部变量表的大小在编译期就被固定下来
- 程序计数器
 - 当前线程的字节码行号指示器，通过改变计数器的值来获取下一条指令。
 - 执行Java方法: 计数器的值是正在执行的虚拟机字节码指令的地址
 - 执行Native方法：计数器的值是空


参考[运行时数据区域-《深入理解JAVA虚拟机》](http://blog.csdn.net/sujz12345/article/details/52074079)


类变量 vs 实例变量 vs 局部变量
- 分配内存的不同
  - 时机不同:
  - 位置不同
    - 类变量分配在方法区
    - 实例变量分配在堆上
- 初始化的不同
  - ```clinit vs init```
  - 类变量在"准备"阶段被赋默认值，在"初始化"阶段被赋初始值。
  - 实例变量在"实例化"阶段赋值

说明："实例化"属于使用阶段。


问题
- 以上各个存储区域是否都被统计到内存空间？(这是一个解决思路)
 - [ ] 方法区
 - [x] VM栈
 - [ ] Native Method栈
 - [x] 堆
 - [ ] 程序计数器
- 如何分别统计以上存储空间？
 - 堆：占比例最大
 - VM栈：占比例次大
 - 方法区：占比例第三
- 实例变量中申请50M的int数组，用dumpsys meminfo看不到？？
 - 这50M空间应该是存储在堆中，堆中为什么看不到？
 - 难道数组有特殊之处？
 - 试试4.0+的手机
- Dalvik/Art跟JavaVM在以下方面的区别
 - 寄存器？
 - 内存模型
 - 类加载过程
 

结论
 - 不同加载阶段的类占用的内存不同
  - 尚未加载的类
    - 以DEX形式存在，只占用外存(odex是否被统计为存储空间里？)
  - 已经加载/但尚未使用的类
    - 方法区域（问题是方法区是否被统计在内存占用里？该区域占比大不大？）
  - 使用到的类
    - 方法区
    - VM栈
    - Native Method栈
    - 堆

结论之Android虚拟机
- 代码区是如何被执行到的
 - dex文件中有专门的代码区，在线程启动后该区域被映射到内存中(mmap)


其它思路
 - 跟百度对比分项数据，例如方法数/方法区的size/堆等
 - 统计启动时有多少类调用了<clinit>和<init>方法，检查不必要的调用
    - 调用clinit占用方法区的空间
    - 调用init占用堆内存的空间
    - 使用JavaAssist来在所有类的以上两个函数中插入字节码，例如打印当前类和类名和函数名
    - 检查不必要加载的类
    - 总结：
        - clinit和init无法通过getDeclaredXXX()获取到，所以没办法插入字节码
        - 可以获取到类的所有初始化函数，插入字节码来输出log，但是log肯定有很多，不好筛选
 - 让内存多存储在Young Generation
    - 多用局部变量，少全局变量，延迟初始化全局变量
 - 编码规范
    - 频繁调用的函数，使用到的局部变量应该升级为类对象变量，防止频繁分配内存/回收内存
    - 不频繁调用的函数，使用到的类对象变量，应该降级为局部变量，防止为这些变量分配内存
 - 从GC的角度来分析内存